/*
 * Utility functions for trap handling in Supervisor mode.
 */

#include "riscv.h"
#include "process.h"
#include "strap.h"
#include "syscall.h"

#include "spike_interface/spike_utils.h"

//
// handling the syscalls. will call do_syscall() defined in kernel/syscall.c
//
static void handle_syscall(trapframe *tf) {
  // tf->epc points to the address that our computer will jump to after the trap handling.
  // for a syscall, we should return to the NEXT instruction after its handling.
  // in RV64G, each instruction occupies exactly 32 bits (i.e., 4 Bytes)
  tf->epc += 4;

  // TODO (lab1_1): remove the panic call below, and call do_syscall (defined in
  // kernel/syscall.c) to conduct real operations of the kernel side for a syscall.
  // IMPORTANT: return value should be returned to user app, or else, you will encounter
  // problems in later experiments!
  // panic( "call do_syscall to accomplish the syscall and lab1_1 here.\n" );
  assert(!do_syscall(tf->regs.a0, tf->regs.a1, tf->regs.a2, tf->regs.a3, tf->regs.a4, tf->regs.a5, tf->regs.a6, tf->regs.a7));
}

//
// global variable that store the recorded "ticks". added @lab1_3
static uint64 g_ticks[NCPU] = {0, 0};
//
// added @lab1_3
//
void handle_mtimer_trap() {
  int hartid = read_tp();
  sprint("Ticks %d\n", g_ticks[hartid]);
  // TODO (lab1_3): increase g_ticks to record this "tick", and then clear the "SIP"
  // field in sip register.
  // hint: use write_csr to disable the SIP_SSIP bit in sip.
  // panic( "lab1_3: increase g_ticks by one, and clear SIP field in sip register.\n" );
  g_ticks[hartid] ++;
  write_csr(sip, 0);
}

//
// kernel/smode_trap.S will pass control to smode_trap_handler, when a trap happens
// in S-mode.
//
void smode_trap_handler(void) {
  // make sure we are in User mode before entering the trap handling.
  // we will consider other previous case in lab1_3 (interrupt).
  if ((read_csr(sstatus) & SSTATUS_SPP) != 0) panic("usertrap: not from user mode");
  // sprint("stop hartid is %0x, and casuse is %p\n", read_tp(), read_csr(scause));
  // panic("stop hartid is %0x, and casuse is %p", read_tp(), read_csr(scause));
  // uint64 Cause = read_csr(scause);
  // sprint("smode_trap_handler(): hartid=%d, scause=%p\n", read_tp(), Cause);
  int hartid = read_tp();
  // DEBUG
  if ((hartid != 0 && hartid != 1) || current[hartid] == NULL) {
    // sprint("come here");
    sprint("smode_trap_handler(): hartid=%d\n", hartid);
    sprint("lgm: %p\n", current[hartid]);
    if (current[hartid] == NULL) {
      sprint("lgm: null\n");
    }
    panic("usertrap: no process, %0x", read_tp());
  }// sprint("smode_trap_handler(): hartid=%d\n", hartid);
  assert(current[hartid]);
  sprint("lgm: not null\n");
  // panic("stop");
  // save user process counter.
  current[hartid]->trapframe->epc = read_csr(sepc);

  // if the cause of trap is syscall from user application.
  // read_csr() and CAUSE_USER_ECALL are macros defined in kernel/riscv.h
  uint64 cause = read_csr(scause);

  // we need to handle the timer trap @lab1_3.
  if (cause == CAUSE_USER_ECALL) {
    handle_syscall(current[hartid]->trapframe);
  } else if (cause == CAUSE_MTIMER_S_TRAP) {  //soft trap generated by timer interrupt in M mode
    handle_mtimer_trap();
  } else {
    sprint("smode_trap_handler(): unexpected scause %p\n", read_csr(scause));
    sprint("            sepc=%p stval=%p\n", read_csr(sepc), read_csr(stval));
    panic( "unexpected exception happened.\n" );
  }

  // continue (come back to) the execution of current process.
  switch_to(current[hartid]);
}
